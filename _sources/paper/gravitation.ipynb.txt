{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Gravitation Example"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import os\n",
    "import tensorflow as tf\n",
    "import torch\n",
    "import maxent\n",
    "from sbi_gravitation import GravitySimulator, sim_wrapper, get_observation_points\n",
    "from torch.distributions.multivariate_normal import MultivariateNormal\n",
    "from sbi.inference import infer\n",
    "import scipy\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.lines import Line2D\n",
    "import seaborn as sns\n",
    "from functools import partialmethod\n",
    "from tqdm import tqdm\n",
    "\n",
    "tqdm.__init__ = partialmethod(tqdm.__init__, disable=True)\n",
    "\n",
    "np.random.seed(12656)\n",
    "sns.set_context(\"paper\")\n",
    "sns.set_style(\n",
    "    \"white\",\n",
    "    {\n",
    "        \"xtick.bottom\": True,\n",
    "        \"ytick.left\": True,\n",
    "        \"xtick.color\": \"#333333\",\n",
    "        \"ytick.color\": \"#333333\",\n",
    "    },\n",
    ")\n",
    "plt.rcParams[\"mathtext.fontset\"] = \"dejavuserif\"\n",
    "colors = [\"#1b9e77\", \"#d95f02\", \"#7570b3\", \"#e7298a\", \"#66a61e\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up true parameters\n",
    "m1 = 100.0  # solar masses\n",
    "m2 = 50.0  # solar masses\n",
    "m3 = 75  # solar masses\n",
    "G = 1.90809e5  # solar radius / solar mass * (km/s)^2\n",
    "v0 = np.array([15.0, -40.0])  # km/s\n",
    "\n",
    "true_params = [m1, m2, m3, v0[0], v0[1]]\n",
    "\n",
    "# set prior means\n",
    "prior_means = [85.0, 40.0, 70.0, 12.0, -30.0]\n",
    "prior_cov = np.eye(5) * 50"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# generate true trajectory and apply some noise to it\n",
    "if os.path.exists(\"true_trajectory.txt\"):\n",
    "    true_traj = np.genfromtxt(\"true_trajectory.txt\")\n",
    "else:\n",
    "    sim = GravitySimulator(m1, m2, m3, v0, G, random_noise=False)\n",
    "    true_traj = sim.run()\n",
    "    np.savetxt(\"true_trajectory.txt\", true_traj)\n",
    "\n",
    "if os.path.exists(\"noisy_trajectory.txt\"):\n",
    "    noisy_traj = np.genfromtxt(\"noisy_trajectory.txt\")\n",
    "else:\n",
    "    sim = GravitySimulator(m1, m2, m3, v0, G, random_noise=True)\n",
    "    noisy_traj = sim.run()\n",
    "    np.savetxt(\"noisy_trajectory.txt\", noisy_traj)\n",
    "\n",
    "observed_points = get_observation_points(noisy_traj)\n",
    "observation_summary_stats = observed_points.flatten()\n",
    "sim = GravitySimulator(m1, m2, m3, v0, G, random_noise=False)\n",
    "sim.run()\n",
    "sim.plot_traj()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "hide-output"
    ]
   },
   "outputs": [],
   "source": [
    "# perform SNL inference\n",
    "prior = MultivariateNormal(\n",
    "    loc=torch.as_tensor(prior_means),\n",
    "    covariance_matrix=torch.as_tensor(torch.eye(5) * 50),\n",
    ")\n",
    "\n",
    "posterior = infer(\n",
    "    sim_wrapper, prior, method=\"SNLE\", num_simulations=2048, num_workers=16\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "hide-output"
    ]
   },
   "outputs": [],
   "source": [
    "# sample from SNL posterior\n",
    "samples = posterior.sample((2000,), x=observation_summary_stats)\n",
    "snl_data = np.array(samples)\n",
    "np.savetxt(\"wide_prior_samples.txt\", snl_data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up restraints for maxent\n",
    "# restraint structure: [value, uncertainty, indices... ]\n",
    "restraints = []\n",
    "for i, point in enumerate(observed_points):\n",
    "    value1 = point[0]\n",
    "    value2 = point[1]\n",
    "    uncertainty = 25\n",
    "    index = 20 * i + 19  # based on how we slice in get_observation_points()\n",
    "    restraints.append([value1, uncertainty, index, 0])\n",
    "    restraints.append([value2, uncertainty, index, 1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up maxent restraints\n",
    "maxent_restraints = []\n",
    "\n",
    "for i in range(len(restraints)):\n",
    "    traj_index = tuple(restraints[i][2:])\n",
    "    value = restraints[i][0]\n",
    "    uncertainty = restraints[i][1]\n",
    "    p = maxent.EmptyPrior()\n",
    "    r = maxent.Restraint(lambda traj, i=traj_index: traj[i], value, p)\n",
    "    maxent_restraints.append(r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# sample from prior for maxent\n",
    "if os.path.exists(\"maxent_prior_samples.npy\"):\n",
    "    prior_dist = np.load(\"maxent_prior_samples.npy\")\n",
    "else:\n",
    "    prior_dist = np.random.multivariate_normal(prior_means, prior_cov, size=2048)\n",
    "    np.save(\"maxent_prior_samples.npy\", prior_dist)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# generate trajectories for maxent from prior samples\n",
    "trajs = np.zeros([prior_dist.shape[0], 100, 2])\n",
    "\n",
    "for i, sample in enumerate(prior_dist):\n",
    "    m1, m2, m3, v0 = sample[0], sample[1], sample[2], sample[3:]\n",
    "    sim = GravitySimulator(m1, m2, m3, v0, random_noise=False)\n",
    "    traj = sim.run()\n",
    "    trajs[i] = traj\n",
    "\n",
    "maxent_trajs = trajs\n",
    "np.save(\"maxent_raw_trajectories.npy\", trajs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# run maxent on trajectories\n",
    "batch_size = prior_dist.shape[0]\n",
    "\n",
    "model = maxent.MaxentModel(maxent_restraints)\n",
    "model.compile(tf.keras.optimizers.Adam(1e-4), \"mean_squared_error\")\n",
    "# short burn-in\n",
    "h = model.fit(trajs, batch_size=batch_size, epochs=5000, verbose=0)\n",
    "# restart to reset learning rate\n",
    "h = model.fit(trajs, batch_size=batch_size, epochs=25000, verbose=0)\n",
    "\n",
    "np.savetxt(\"maxent_loss.txt\", h.history[\"loss\"])\n",
    "\n",
    "maxent_weights = model.traj_weights\n",
    "np.savetxt(\"maxent_traj_weights.txt\", maxent_weights)\n",
    "\n",
    "maxent_avg_traj = np.sum(trajs * maxent_weights[:, np.newaxis, np.newaxis], axis=0)\n",
    "np.savetxt(\"maxent_avg_traj.txt\", maxent_avg_traj)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Plotting Results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# simulate traj generated by prior means\n",
    "sim = GravitySimulator(prior_means[0], prior_means[1], prior_means[2], prior_means[3:])\n",
    "prior_means_traj = sim.run()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# simulate trajectories from SNL samples\n",
    "snl_trajs = np.zeros([snl_data.shape[0], noisy_traj.shape[0], noisy_traj.shape[1]])\n",
    "for i, sample in enumerate(snl_data):\n",
    "    m1, m2, m3, v0 = sample[0], sample[1], sample[2], [sample[3], sample[4]]\n",
    "    sim = GravitySimulator(m1, m2, m3, v0)\n",
    "    traj = sim.run()\n",
    "    snl_trajs[i] = traj\n",
    "\n",
    "mean_snl_traj = np.mean(snl_trajs, axis=0)\n",
    "np.savetxt(\"mean_snl_traj.txt\", mean_snl_traj)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "alpha_val = 0.7\n",
    "fig, axes = plt.subplots(figsize=(5, 3), dpi=300)\n",
    "\n",
    "# plot the observation points\n",
    "axes.scatter(\n",
    "    observed_points[:, 0],\n",
    "    observed_points[:, 1],\n",
    "    color=\"black\",\n",
    "    zorder=10,\n",
    "    marker=\"*\",\n",
    "    label=\"Observed Points\",\n",
    ")\n",
    "\n",
    "# plot the trajectory generated by prior means\n",
    "sim.set_traj(prior_means_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Greys\").reversed(),\n",
    "    color=\"grey\",\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\"-.\",\n",
    "    linewidth=1,\n",
    "    label=\"Prior Mean\",\n",
    ")\n",
    "\n",
    "# plot the SNL mean trajectory\n",
    "sim.set_traj(mean_snl_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Greens\").reversed(),\n",
    "    color=colors[0],\n",
    "    fade_lines=False,\n",
    "    linewidth=1,\n",
    "    alpha=alpha_val,\n",
    "    label=\"SNL\",\n",
    ")\n",
    "\n",
    "# plot the true trajectory\n",
    "sim.set_traj(true_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Reds\").reversed(),\n",
    "    color=\"black\",\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\":\",\n",
    "    linewidth=1,\n",
    "    label=\"True Path\",\n",
    "    label_attractors=False,\n",
    ")\n",
    "\n",
    "# plot the maxent average trajectory\n",
    "sim.set_traj(maxent_avg_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Oranges\").reversed(),\n",
    "    color=colors[2],\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\"-\",\n",
    "    linewidth=1,\n",
    "    label=\"MaxEnt\",\n",
    "    label_attractors=True,\n",
    ")\n",
    "\n",
    "# set limits manually\n",
    "axes.set_xlim(-5, 130)\n",
    "axes.set_ylim(-30, 75)\n",
    "\n",
    "plt.legend(loc=\"upper left\", bbox_to_anchor=(1.05, 1.0))\n",
    "plt.tight_layout()\n",
    "\n",
    "# plt.savefig('paths_compare.png')\n",
    "# plt.savefig('paths_compare.svg')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# set up KDE plotting of posteriors\n",
    "column_names = [\"m1\", \"m2\", \"m3\", \"v0x\", \"v0y\"]\n",
    "\n",
    "snl_dist = np.array(snl_data)\n",
    "snl_frame = pd.DataFrame(snl_dist, columns=column_names)\n",
    "\n",
    "maxent_dist = np.load(\"maxent_prior_samples.npy\")\n",
    "maxent_frame = pd.DataFrame(maxent_dist, columns=column_names)\n",
    "\n",
    "fig, axes = plt.subplots(nrows=5, ncols=1, figsize=(5, 5), dpi=300, sharex=False)\n",
    "\n",
    "# iterate over the five parameters\n",
    "n_bins = 30\n",
    "for i, key in enumerate(column_names):\n",
    "    sns.histplot(\n",
    "        data=snl_frame,\n",
    "        x=key,\n",
    "        ax=axes[i],\n",
    "        color=colors[0],\n",
    "        stat=\"probability\",\n",
    "        element=\"step\",\n",
    "        kde=True,\n",
    "        fill=False,\n",
    "        bins=n_bins,\n",
    "        lw=1.0,\n",
    "    )\n",
    "    sns.histplot(\n",
    "        data=maxent_frame,\n",
    "        x=key,\n",
    "        ax=axes[i],\n",
    "        color=colors[2],\n",
    "        stat=\"probability\",\n",
    "        element=\"step\",\n",
    "        kde=True,\n",
    "        fill=False,\n",
    "        bins=n_bins,\n",
    "        weights=maxent_weights,\n",
    "        lw=1.0,\n",
    "    )\n",
    "    sns.histplot(\n",
    "        data=maxent_frame,\n",
    "        x=key,\n",
    "        ax=axes[i],\n",
    "        color=colors[3],\n",
    "        stat=\"probability\",\n",
    "        element=\"step\",\n",
    "        kde=True,\n",
    "        fill=False,\n",
    "        bins=n_bins,\n",
    "        lw=1.0,\n",
    "    )\n",
    "    axes[i].axvline(prior_means[i], ls=\"-.\", color=\"grey\", lw=1.2)\n",
    "    axes[i].axvline(true_params[i], ls=\":\", color=\"black\", lw=1.2)\n",
    "    axes[i].set_xlabel(key)\n",
    "\n",
    "# custom lines object for making legend\n",
    "custom_lines = [\n",
    "    Line2D([0], [0], color=colors[3], lw=2),\n",
    "    Line2D([0], [0], color=colors[0], lw=2),\n",
    "    Line2D([0], [0], color=colors[2], lw=2),\n",
    "    Line2D([0], [0], color=\"black\", ls=\":\", lw=2),\n",
    "    Line2D([0], [0], color=\"grey\", ls=\"-.\", lw=2),\n",
    "]\n",
    "axes[0].legend(\n",
    "    custom_lines,\n",
    "    [\"Prior\", \"SNL\", \"MaxEnt\", \"True Parameters\", \"Prior Mean\"],\n",
    "    loc=\"upper left\",\n",
    "    bbox_to_anchor=(1.05, 1.0),\n",
    ")\n",
    "plt.tight_layout()\n",
    "\n",
    "# plt.savefig('posterior_compare.png')\n",
    "# plt.savefig('posterior_compare.svg')\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# calculating cross-entropy values\n",
    "def get_crossent(\n",
    "    prior_samples,\n",
    "    posterior_samples,\n",
    "    epsilon=1e-7,\n",
    "    x_range=[-100, 100],\n",
    "    nbins=40,\n",
    "    post_weights=None,\n",
    "):\n",
    "    prior_dists = []\n",
    "    posterior_dists = []\n",
    "    crossents = []\n",
    "    for i in range(5):\n",
    "        prior_dist, _ = np.histogram(\n",
    "            prior_samples[:, i], bins=nbins, range=x_range, density=True\n",
    "        )\n",
    "        prior_dists.append(prior_dist)\n",
    "        posterior_dist, _ = np.histogram(\n",
    "            posterior_samples[:, i],\n",
    "            bins=nbins,\n",
    "            range=x_range,\n",
    "            density=True,\n",
    "            weights=post_weights,\n",
    "        )\n",
    "        posterior_dists.append(posterior_dist)\n",
    "        crossents.append(np.log(posterior_dist + epsilon) * (prior_dist + epsilon))\n",
    "    return -np.sum(crossents)\n",
    "\n",
    "\n",
    "snl_prior = np.random.multivariate_normal(\n",
    "    mean=prior_means, cov=np.eye(5) * 50, size=snl_dist.shape[0]\n",
    ")\n",
    "snl_crossent = get_crossent(snl_prior, snl_dist)\n",
    "\n",
    "maxent_prior = np.random.multivariate_normal(prior_means, np.eye(5) * 50, size=2048)\n",
    "maxent_crossent = get_crossent(maxent_prior, maxent_prior, post_weights=maxent_weights)\n",
    "\n",
    "print(f\"CROSS-ENTROPY:\\nSNL: {snl_crossent}\\nMaxEnt: {maxent_crossent}\")\n",
    "\n",
    "crossent_values = [snl_crossent, maxent_crossent]\n",
    "np.savetxt(\"crossent_values.txt\", np.array(crossent_values), header=\"SNL, MaxEnt\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### MaxEnt With Variational"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import tensorflow_probability as tfp\n",
    "\n",
    "tfd = tfp.distributions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "x = np.array(prior_means, dtype=np.float32)\n",
    "y = np.array(prior_cov, dtype=np.float32)\n",
    "i = tf.keras.Input((100, 2))\n",
    "l = maxent.TrainableInputLayer(x)(i)\n",
    "d = tfp.layers.DistributionLambda(\n",
    "    lambda x: tfd.MultivariateNormalFullCovariance(loc=x, covariance_matrix=y)\n",
    ")(l)\n",
    "model = maxent.ParameterJoint([lambda x: x], inputs=i, outputs=[d])\n",
    "model.compile(tf.keras.optimizers.SGD(1e-3))\n",
    "model.summary()\n",
    "model(tf.constant([1.0, 2.0, 3.0, 4.0, 5.0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def simulate(x, nsteps=100):\n",
    "    \"\"\"params_list should be: m1, m2, m3, v0[0], v0[1] in that order\"\"\"\n",
    "    # double nsteps b/c we flatten the (x,y) coordinates\n",
    "    output = np.zeros((x.shape[0], nsteps, 2))\n",
    "    for i in range(x.shape[0]):\n",
    "        params_list = x[i, 0, :]\n",
    "        m1, m2, m3 = float(params_list[0]), float(params_list[1]), float(params_list[2])\n",
    "        v0 = np.array([params_list[3], params_list[4]], dtype=np.float64)\n",
    "        this_sim = GravitySimulator(m1, m2, m3, v0, random_noise=False, nsteps=nsteps)\n",
    "        # set to 1D to make hypermaxent setup easier\n",
    "        this_traj = this_sim.run()  # .flatten()\n",
    "        output[i] = this_traj\n",
    "    return output"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "def get_observation_points_from_flat(flat_traj):\n",
    "    recovered_traj = flat_traj.reshape([-1, 2])\n",
    "    return get_observation_points(recovered_traj)  # .flatten()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "r = []\n",
    "true_points = get_observation_points(noisy_traj)\n",
    "true_points_flat = true_points.flatten()\n",
    "for i, point in enumerate(true_points_flat):\n",
    "    r.append(\n",
    "        maxent.Restraint(\n",
    "            lambda x: get_observation_points_from_flat(x)[i], point, maxent.EmptyPrior()\n",
    "        )\n",
    "    )\n",
    "hme_model = maxent.HyperMaxentModel(maxent_restraints, model, simulate)\n",
    "hme_model.compile(tf.keras.optimizers.Adam(1e-4), \"mean_squared_error\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "hme_results = hme_model.fit(\n",
    "    epochs=30000, sample_batch_size=2048 // 4, outter_epochs=4, verbose=0\n",
    ")  # one-quarter of plain maxent batch size"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "hme_predicted_params = hme_model.weights[1]\n",
    "hme_trajectory_weights = hme_model.traj_weights\n",
    "variational_trajs = hme_model.trajs.reshape([hme_model.trajs.shape[0], -1, 2])\n",
    "maxent_variational_avg_traj = np.sum(\n",
    "    variational_trajs * hme_trajectory_weights[:, np.newaxis, np.newaxis], axis=0\n",
    ")\n",
    "np.savetxt(\"maxent_variational_avg_traj.txt\", maxent_variational_avg_traj)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# simulate traj generated by prior means\n",
    "sim = GravitySimulator(prior_means[0], prior_means[1], prior_means[2], prior_means[3:])\n",
    "prior_means_traj = sim.run()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mean_snl_traj = np.genfromtxt(\"mean_snl_traj.txt\")\n",
    "maxent_avg_traj = np.genfromtxt(\"maxent_avg_traj.txt\")\n",
    "maxent_variational_avg_traj = np.genfromtxt(\"maxent_variational_avg_traj.txt\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "alpha_val = 0.7\n",
    "fig, axes = plt.subplots(figsize=(5, 3), dpi=300)\n",
    "\n",
    "# plot the observation points\n",
    "axes.scatter(\n",
    "    observed_points[:, 0],\n",
    "    observed_points[:, 1],\n",
    "    color=\"black\",\n",
    "    zorder=10,\n",
    "    marker=\"*\",\n",
    "    label=\"Observed Points\",\n",
    ")\n",
    "\n",
    "# plot the trajectory generated by prior means\n",
    "sim.set_traj(prior_means_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Greys\").reversed(),\n",
    "    color=\"grey\",\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\"-.\",\n",
    "    linewidth=1,\n",
    "    label=\"Prior Mean\",\n",
    ")\n",
    "\n",
    "# plot the SNL mean trajectory\n",
    "sim.set_traj(mean_snl_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Greens\").reversed(),\n",
    "    color=colors[0],\n",
    "    fade_lines=False,\n",
    "    linewidth=1,\n",
    "    alpha=alpha_val,\n",
    "    label=\"SNL\",\n",
    ")\n",
    "\n",
    "# plot the true trajectory\n",
    "sim.set_traj(true_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Reds\").reversed(),\n",
    "    color=\"black\",\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\":\",\n",
    "    linewidth=1,\n",
    "    label=\"True Path\",\n",
    "    label_attractors=False,\n",
    ")\n",
    "\n",
    "# plot the maxent average trajectory\n",
    "sim.set_traj(maxent_avg_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Oranges\").reversed(),\n",
    "    color=colors[2],\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\"-\",\n",
    "    linewidth=1,\n",
    "    label=\"MaxEnt\",\n",
    "    label_attractors=False,\n",
    ")\n",
    "\n",
    "# plot the maxent average trajectory\n",
    "sim.set_traj(maxent_variational_avg_traj)\n",
    "sim.plot_traj(\n",
    "    fig=fig,\n",
    "    axes=axes,\n",
    "    make_colorbar=False,\n",
    "    save=False,\n",
    "    cmap=plt.get_cmap(\"Oranges\").reversed(),\n",
    "    color=colors[3],\n",
    "    fade_lines=False,\n",
    "    alpha=alpha_val,\n",
    "    linestyle=\"-\",\n",
    "    linewidth=1,\n",
    "    label=\"Variational MaxEnt\",\n",
    "    label_attractors=True,\n",
    ")\n",
    "\n",
    "# set limits manually\n",
    "axes.set_xlim(-5, 130)\n",
    "axes.set_ylim(-30, 75)\n",
    "\n",
    "plt.legend(loc=\"upper left\", bbox_to_anchor=(1.05, 1.0))\n",
    "plt.tight_layout()\n",
    "\n",
    "plt.savefig(\"paths_compare.png\")\n",
    "plt.savefig(\"paths_compare.svg\")\n",
    "plt.show()"
   ]
  }
 ],
 "metadata": {
  "celltoolbar": "Tags",
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
